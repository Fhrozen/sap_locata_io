function struct2csv( in, opts )

% function struct2csv( in, opts )    
% Converts Matlab structure to CSV file(s).
%
% Inputs:
%   in:         Structure containing the following fields:
%     in.struct
%     in.save_dir
%     in.struct_type
%   opts:       Structure of parameters as generated by init
%
% Outputs: N/A (writting to file)
%
% Author: Christine Evers, c.evers@imperial.ac.uk
%
% Notice: This is part of the LOCATA evaluation release. Please report
%         problems and bugs to info@locata-challenge.org.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF OPEN DATA
% COMMONS ATTRIBUTION LICENSE (ODC-BY) v1.0, WHICH CAN BE FOUND AT
% http://opendatacommons.org/licenses/by/1.0/.
% THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE
% OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW
% IS PROHIBITED.
%
% BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
% TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
% BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
% CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
% CONDITIONS.
%
% -------------------------------------------------------------------------
%
% Representations, Warranties and Disclaimer
%
% UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
% OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
% KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
% INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
% LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
% WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE
% EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
%
% Limitation on Liability.
%
% EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL
% LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL,
% INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF
% THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED
% OF THE POSSIBILITY OF SUCH DAMAGES.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

timestamps = in.struct.time;
[~,Ns] = size(timestamps);
if size(in.struct.time,1) ~= 6 || size(in.struct.time,2) <= 1
    error(['position must be a 6x', num2str(Ns), ' matrix, where the number of samples, T > 1.']);
end

switch in.struct_type
    case 'position_array'
        arrays = fieldnames(in.struct.data);
        if ~isempty(setxor(arrays, opts.valid_arrays))
            if sum(strcmp(setxor(arrays, opts.valid_arrays), 'dummy')) && (~isempty(regexp(in.save_dir, 'task5')) || ~isempty(regexp(in.save_dir, 'task4')) )
                disp('Task4/5: Dummy data does not exist. This is as expected.')
            elseif ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'benchmark2' ) ) && ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'dicit' ) )...
                    && ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'eigenmike' ) )&& (~isempty(regexp(in.save_dir, 'task7')) || ~isempty(regexp(in.save_dir, 'task6')))
                disp('Task6/7: DICIT, benchmark, eigenmike do not exist. This is as expected.')
            else
                disp('Unexpected field(s):');
                disp(setxor(arrays, opts.valid_arrays))
                error('Invalid array name')
            end
        end

        for arr_idx = 1 : length(arrays)
            % Check all fields in array data are valid (as defined in opts)
            if ~isempty(setxor(fieldnames(in.struct.data.(arrays{arr_idx})), opts.fields_position_array))
                disp('Unexpected field(s):')
                disp(setxor(fieldnames(in.struct.data.(arrays{arr_idx})), opts.fields_position_array))
                error('Invalid array field name');
            end

            % Check if microphone positions are specified in data
            % structure:
            if sum(strcmp('mic', fieldnames(in.struct.data.(arrays{arr_idx})))) ~= 1
                error(['Microphone positions do not exist for array ', arrays{arr_idx}])
            end

            in_array = in;
            in_array.array = arrays{arr_idx};
            in_array.timestamps = timestamps; % Is cropped to valid indices inside of position2struct
            this_array = position2struct( in_array, Ns );

            if sum(strcmp('mic', fieldnames(in.struct.data.(arrays{arr_idx})))) == 1
                if size(in.struct.data.(arrays{arr_idx}).mic,1) ~= 3 || size(in.struct.data.(arrays{arr_idx}).mic,2) ~= Ns || size(in.struct.data.(arrays{arr_idx}).mic,3) ~= opts.(arrays{arr_idx}).M
                    error(['mic vector must be a 3x', num2str(Ns), 'x',num2str(opts.(arrays{arr_idx}).M), ' matrix.']);
                end
                for m = 1 : opts.(arrays{arr_idx}).M
                    this_array.(['mic', num2str(m), '_x']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(1,:,m))';
                    this_array.(['mic', num2str(m), '_y']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(2,:,m))';
                    this_array.(['mic', num2str(m), '_z']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(3,:,m))';
                end

                % Remove invalid time stamps from microphone positions:
                for m = 1 : opts.(arrays{arr_idx}).M
                    this_array.(['mic', num2str(m), '_x']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(1,:,m))';
                    this_array.(['mic', num2str(m), '_y']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(2,:,m))';
                    this_array.(['mic', num2str(m), '_z']) = squeeze(in.struct.data.(arrays{arr_idx}).mic(3,:,m))';
                end

            end

            % Write to Table and rename headers
            this_table = struct2table(this_array);
            writetable(this_table, [in.save_dir, 'position_array_', arrays{arr_idx}], 'Delimiter', '\t');

            clear this_array this_table
        end
    case 'position_source'
        sources = fieldnames(in.struct.data);
        for src_idx = 1 : length(sources)
            if sum(strcmp( sources{src_idx}, opts.valid_sources)) ~= 1
                error('Unexpected source name.')
            end

            source_data = fieldnames(in.struct.data.(sources{src_idx}));
            if isempty(setxor(source_data, 'valid_time'))
                error(['Position data for source ', sources{src_idx}, ' does not contain valid_times.'])
            end

            % Check all fields in source data are valid (as defined in opts)
            if ~isempty(setxor(fieldnames(in.struct.data.(sources{src_idx})), opts.fields_position_source))
                disp('Unexpected field(s):')
                disp(setxor(fieldnames(in.struct.data.(sources{src_idx})), opts.fields_position_source))
                error('Invalid source name');
            end

            in_array = in;
            in_array.array = sources{src_idx};
            in_array.timestamps = timestamps;       % Is cropped to valid indices inside of position2struct
            this_array = position2struct( in_array, Ns);

            % Write to Table and rename headers
            this_table = struct2table(this_array);
            writetable(this_table, [in.save_dir, 'position_source_', sources{src_idx}], 'Delimiter', '\t');

            clear this_array this_table
        end
    case 'audio_source'
        sources = fieldnames(in.struct.data);
        if sum( strcmp(fieldnames(in.struct.VAD), sources )) ~= length(sources)
            disp('Unexpected field(s):')
            disp(setxor(fieldnames(in.struct.VAD), sources ))
            error('Sources in VAD and in data do not match.')
        end
        if ~isempty(setxor(fieldnames(in.struct), opts.fields_audio_source))
            disp('Unexpected field(s):')
            disp(setxor(sources, opts.fields_audio_source))
            error('Invalid field name')
        end

        for src_idx = 1 : length(sources)
            if sum( strcmp(sources{src_idx}, opts.valid_sources)) ~= 1
                disp('Unexpected field(s):')
                disp(setxor(sources{src_idx}, opts.valid_sources))
                error('Invalid source name')
            end

            this_source = [];
            this_source.year = in.struct.time(1,:)';
            this_source.month = in.struct.time(2,:)';
            this_source.day = in.struct.time(3,:)';
            this_source.hour = in.struct.time(4,:)';
            this_source.minute = in.struct.time(5,:)';
            this_source.second = in.struct.time(6,:)';
            this_source.VAD = in.struct.VAD.(sources{src_idx});

            % Write audio to file:
            audio_fname = [in.save_dir, 'audio_source_', sources{src_idx}, '.wav'];
            audiowrite(audio_fname, in.struct.data.(sources{src_idx}), in.struct.fs);

            this_table = struct2table(this_source);
            writetable(this_table, [in.save_dir, 'audio_source_', sources{src_idx}], 'Delimiter', '\t');
        end
    case 'audio_array'
        arrays = fieldnames(in.struct.data);
        if ~isempty(setxor(arrays, opts.valid_arrays))
            if sum(strcmp(setxor(arrays, opts.valid_arrays), 'dummy')) && (~isempty(regexp(in.save_dir, 'task5')) || ~isempty(regexp(in.save_dir, 'task4')) )
                disp('Task4/5: Dummy data does not exist. This is as expected.')
            elseif ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'benchmark2' ) ) && ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'dicit' ) )...
                    && ~isempty( intersect( setxor(arrays, opts.valid_arrays), 'eigenmike' ) )&& (~isempty(regexp(in.save_dir, 'task7')) || ~isempty(regexp(in.save_dir, 'task6')))
                disp('Task6/7: DICIT, benchmark, eigenmike do not exist. This is as expected.')
            else
                disp('Unexpected field(s):');
                disp(setxor(arrays, opts.valid_arrays))
                error('Invalid array name')
            end
        end

        for arr_idx = 1 : length(arrays)
            % Write audio to file:
            audio_fname = [in.save_dir, 'audio_array_', arrays{arr_idx}, '.wav'];
            audiowrite(audio_fname, in.struct.data.(arrays{arr_idx}), in.struct.fs);
        end
    otherwise
        error(['Structure in.struct_type must be position_array, position_source, audio_source, or audio_array']);
end

end

function this_position = position2struct(in, Ns)

if size(in.struct.data.(in.array).position,1) ~= 3 || size(in.struct.data.(in.array).position,2) ~= Ns
    error(['position must be a 3x', num2str(Ns), ' matrix.']);
end
if size(in.struct.data.(in.array).ref_vec,1) ~= 3 || size(in.struct.data.(in.array).ref_vec,2) ~= Ns
    error(['ref_vec must be a 3x', num2str(Ns), ' matrix.']);
end

this_position = [];
this_position.year = in.timestamps(1,:)';
this_position.month = in.timestamps(2,:)';
this_position.day = in.timestamps(3,:)';
this_position.hour = in.timestamps(4,:)';
this_position.minute = in.timestamps(5,:)';
this_position.second = in.timestamps(6,:)';
this_position.x = in.struct.data.(in.array).position(1,:)';
this_position.y = in.struct.data.(in.array).position(2,:)';
this_position.z = in.struct.data.(in.array).position(3,:)';
this_position.ref_vec_x = in.struct.data.(in.array).ref_vec(1,:)';
this_position.ref_vec_y = in.struct.data.(in.array).ref_vec(2,:)';
this_position.ref_vec_z = in.struct.data.(in.array).ref_vec(3,:)';
end
