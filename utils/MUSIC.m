function out = MUSIC(in, opts)

% function out = MUSIC(in, opts)
% implementation of Multiple SIgnal Classification (MUSIC) algorithm as described in [3].
%
% Inputs:
%   in:
%     in.array:               String containing array name: 'eigenmike', 'dicit', 'dummy', 'benchmark2'
%     in.y:                   Data matrix
%     in.fs:                  Sampling frequency [Hz]
%     in.timestamps:          Vector of timestamps at which DoA estimates must be PROVIDED
%     in.time:                6xT matrix of system clock times
%     in.array.rotation:      Rotation matrix describing array orientation in 3D for each timestamp
%     in.array.mic:           Matrix describing microphone positions for each timestamp
%   opts:                     Settings structure generated by init()
%
% Outputs:
%   out:
%     out.source:             N x 1 struct array, one element for each N estimated sources. In this function: N = 1 (single-source)
%     out.source(src_idx).azimuth:      Tx1 vector of azimuth estimates, where T is the number of timestamps in in.timestamps
%     out.source(src_idx).elevation:    Tx1 vector of elevation estimates
%     out.source(src_idx).time:         Tx1 vector of system time values of estimates (must be identical to in.time!)
%     out.source(src_idx).timestamps:   Tx1 vector of timestamps of estimates (must be identical to in.timestamps!)
%
% References:
% [1]	J. Benesty, C. Jingdong, and I. Cohen, Design of Circular Differential Microphone Arrays. Springer, 2015.
% [2]	I. Cohen, J. Benesty, and S. Gannot, Speech Processing in Modern Communication, vol. 3. Berlin, Heidelberg: Springer Science & Business Media, 2009.
% [3]	H. L. Van Trees, Detection, Estimation, and Modulation Theory, Optimum Array Processing. John Wiley & Sons, 2004.
%
% Author: Christine Evers, c.evers@imperial.ac.uk
%
% Notice: This is part of the LOCATA evaluation release. Please report
%         problems and bugs to info@locata-challenge.org.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF OPEN DATA
% COMMONS ATTRIBUTION LICENSE (ODC-BY) v1.0, WHICH CAN BE FOUND AT
% http://opendatacommons.org/licenses/by/1.0/.
% THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE
% OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW
% IS PROHIBITED.
%
% BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
% TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
% BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
% CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
% CONDITIONS.
%
% -------------------------------------------------------------------------
%
% Representations, Warranties and Disclaimer
%
% UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
% OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
% KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
% INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
% LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
% WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE
% EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
%
% Limitation on Liability.
%
% EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL
% LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL,
% INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF
% THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED
% OF THE POSSIBILITY OF SUCH DAMAGES.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

az = -pi:deg2rad(5):pi;           % Azimuth - note that this is denoted as el in [2]

% Boresight elevation = pi/2, i.e., elevation = inclination (see comment after (8.39) in [2]:
el = 0:deg2rad(10):pi;                        % Elevation - note that this is denoted as az in [2]

%% Steering vectors
%
% Choose linear sub-arrays

switch in.array_name
    case 'dicit'
        % Use subarray:
        subarray = [6 7 9];
        ref_mic = 1;
    case 'benchmark2'
        subarray = 1 : 12;
        ref_mic = 1;
    case 'eigenmike'
        % All mics at elevaiton 90 deg:
        subarray = 1 : 32;
        ref_mic = 1;            % index in subarray of reference mic
    case 'dummy'
        subarray = 1:4;
        ref_mic = 1;
    otherwise
        error(['Array type ', in.array_name, ' does not exist.']);
end

%% MUSIC

numMic = length(subarray);

fftPoint = 1024;
frame_duration = 0.03;
frames_per_block = 100;                     	% Number of frames per block
block_step = 10;

frame_length = frame_duration * in.fs;

%% OptiTracker sampling rate

% Unique timestamps:
[opti_timestamps,unique_idx] = unique(in.timestamps);
opti_rotation = in.array.rotation(:,unique_idx,:);
opti_mics = in.array.mic(:,unique_idx,:);

%% STFT

[X,frame_timestamps,f] = stft(in.y(subarray,:,:)',hamming(frame_length),frame_length/4,fftPoint,in.fs);
X = permute(X, [3 1 2]);
nframe = length(frame_timestamps);

% Check that the frame times and Optitracker times intersect:
opti_timestamps( opti_timestamps > frame_timestamps(end) ) = [];

%% MUSIC

% Note: Beware of the conjugate... Using transpose and ctranspose
% explicitly to avoid bugs due to Matlab ' vs .'

% Make blocks out of frames:
frame_srt = 1 : block_step : nframe;
frame_end = frames_per_block : block_step : size(X,1);
frame_end = [frame_end, size(X,1)*ones(1,length(frame_srt)-length(frame_end))];
nblocks = length(frame_srt);
block_timestamps = mean([frame_timestamps(frame_srt)',frame_timestamps(frame_end)'],2)';

% Bandlimit signals to avoid spatial aliasing / low freq effects:
% NOTE: This is crucial for the DICIT array, the other arrays can be
% evaluated for fullband signals.
valid_freq_idx = f > 800 & f < 1400;
valid_freqs = f(valid_freq_idx);
valid_X = X(:,valid_freq_idx,:);

power = zeros(fftPoint/2-1, length(az), length(el), nblocks);
for block_idx = 1 : nblocks
    for freq_idx = 1:length(valid_freqs)%1 : fftPoint/2-1
        % Block of FFT frames:
        data_block = squeeze(valid_X(frame_srt(block_idx):frame_end(block_idx),freq_idx,:));
        if size(data_block,2) > 1       % ensure svd does not result in empty U

            % Find nearest OptiTrac sample:
            diff = abs(bsxfun(@minus,block_timestamps(block_idx), opti_timestamps));
            [~, closest_opti_idx] = min(diff);

            % Autocorrelation
            Rxx = (transpose(data_block)*conj(data_block));

            % Rxx = U * S * U^H, see [3] eq. (9.32)
            [U,~,~] = svd(Rxx);

            % [3] eq. (9.37), using spectral sparsity assumption:
            % Signal subspace is 1 dimensional if 1 source is active, hence D = 1
            Un = U(:,2:end);

            % Power for each az/el grid point:
            for az_idx = 1 : length(az)
                for el_idx = 1 : length(el)
                    % [2] eq (8.35) modified s.th. az = 0 and el = pi/2 result in eta = [0 1 0],
                    % i.e., pointing along y-axis:
                    eta = [-sin(el(el_idx)).*sin(az(az_idx)); sin(el(el_idx)).*cos(az(az_idx)); cos(el(el_idx))];
                    rot_eta = squeeze(opti_rotation(:,closest_opti_idx,:)) * eta;

                    % [2] eq (8.36) - TDoA:
                    tau = 1/opts.c * transpose(rot_eta) * (squeeze(opti_mics(:,closest_opti_idx,subarray)) - repmat(opti_mics(:,closest_opti_idx,subarray(ref_mic)), 1, numMic));

                    % [2] eq (8.34) - Steering vector:
                    SV = transpose(exp(1i*2*pi*valid_freqs(freq_idx).*tau));

                    % [3] eq. (9.44):
                    power(freq_idx,az_idx,el_idx,block_idx) = 1./(sum(abs( ctranspose(SV) * Un * ctranspose(Un) * SV )));
                end
            end
        end
    end
end

% Sum spectra over all frequencies:
spectrum = zeros( nblocks, length(az), length(el) );
for block_idx = 1 : nblocks
    spectrum(block_idx,:,:) = sum(power(:,:,:,block_idx),1);
end

%% Find DOA
%
% NOTE: Single-source assumption

azimuth = nan(1,nblocks);
elevation = nan(1,nblocks);
for block_idx = 1 : nblocks
    if size(spectrum,3) == 1
        [~,locs] = findpeaks(spectrum(block_idx,:),'SortStr','descend', 'NPeaks', 1);

        if ~isempty(locs)
            azimuth(block_idx) = az(locs);
        end
    else
        [mesh_az, mesh_el] = meshgrid(az, el);
        mesh_az = mesh_az';
        mesh_el = mesh_el';
        mesh_spec = squeeze(spectrum(block_idx,:,:));

        % Extract regional maxima:
        locs = find(imregionalmax(mesh_spec));
        peak_vals = mesh_spec(locs);
        % Global maximum:
        [~,max_peak] = max(peak_vals);
        locs = locs(max_peak);
        [loc_az,loc_el] = ind2sub(size(mesh_spec), locs);
        azimuth(block_idx) = az(loc_az);
        elevation(block_idx) = el(loc_el);
    end

end

%% Interpolate estimates to OptiTracker timestamps

% Interpolate MUSIC estimates to required time stamps:
interp_azimuth = interp1(block_timestamps, azimuth, in.timestamps);
interp_elevation = interp1(block_timestamps, elevation, in.timestamps);

%% Output 1 - interpolated

% MUSIC estimates single source only:
N_sources = 1;

for src_idx = 1 : N_sources
    % Initialize so all fields exist but are empty if not used / applicable
    for f_idx = 1 : length(opts.valid_results)
        out.source(src_idx).(opts.valid_results{f_idx}) = [];
    end

    % Populate applicable fields:
    out.source(src_idx).azimuth = wrapToPi(interp_azimuth);
    if size(spectrum,3) > 1
        out.source(src_idx).elevation = wrapToPi(interp_elevation);
    end
    out.source(src_idx).time = in.time;
    out.source(src_idx).timestamps = in.timestamps;
end

end
